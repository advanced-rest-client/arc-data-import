<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="data-transformer-behavior.html">
<!--
An element to transform data expored in Postman into ARC's data model.
-->
<script>
  Polymer({
    is: 'postman-data-tranformer',

    behaviors: [ArcBehaviors.ImportDataTransformerBehavior],

    transform: function(data) {
      switch (data.version) {
        case 1: return this._readPostmanData(data);
        default: return Promise.reject('Unsupported Postman version.');
      }
    },

    _readPostmanData: function(data) {
      var collections = this._readRequestsData(data.collections);
      var result = {
        createdAt: new Date().toISOString(),
        version: 'postman-v1',
        kind: 'ARC#Import',
        requests: collections.requests,
        projects: collections.projects
      };

      if (data.headerPresets && data.headerPresets.length) {
        result['headers-sets'] = this._computeHeadersSets(data.headerPresets);
      }

      var variables = this._computeVariables(data);
      if (variables && variables.length) {
        result.variables = variables;
      }

      return Promise.resolve(result);
    },

    _readRequestsData: function(data) {
      var result = {
        projects: [],
        requests: []
      };
      if (!data || !data.length) {
        return result;
      }
      var parts = data.map((item, index) => this._readCollectionData(item, index));
      parts.forEach(data => {
        result.projects.push(data.project);
        result.requests = result.requests.concat(data.requests);
      });
      return result;
    },

    _readCollectionData: function(collection, index) {
      var result = {
        project: {},
        requests: []
      };
      result.project._id = collection.id;
      result.project.name = collection.name;
      result.project.description = collection.description;
      result.project.order = index;
      result.project.created = collection.createdAt;
      result.project.updated = collection.updatedAt;
      var requests = this._computeRequestsOrder(collection);
      result.requests = requests.map((item, index) =>
        this._createRequestObject(item, collection.id, index));
      return result;
    },

    _computeRequestsOrder: function(collection) {
      var ordered = [];
      if (collection.order && collection.order.length) {
        ordered = ordered.concat(collection.order);
      }
      // jscs:disable requireCamelCaseOrUpperCaseIdentifiers
      var folders = this._computeOrderedFolders(collection.folders, collection.folders_order);
      // jscs:enable requireCamelCaseOrUpperCaseIdentifiers
      if (folders) {
        folders.forEach(folder => {
          if (folder.order && folder.order.length) {
            ordered = ordered.concat(folder.order);
          }
        });
      }
      var requests = collection.requests;
      var result = ordered.map(id => {
        return requests.find(request => request.id === id);
      });
      result = result.filter(item => !!item);
      return result;
    },

    _computeOrderedFolders: function(folders, orderIds) {
      if (!folders || !folders.length) {
        return;
      }
      if (!orderIds || !orderIds.length) {
        return folders;
      }
      var result = orderIds.map(id => {
        return folders.find(folder => folder.id === id);
      });
      result = result.filter(item => !!item);
      return result;
    },

    _createRequestObject: function(item, projectId, projectIndex) {
      item.name = item.name || 'unnamed';
      item.url = item.url || 'http://';
      item.method = item.method || 'GET';
      var body = this._computeBody(item);
      var id = this.generateRequestId(item, projectId);
      var created = Number(item.time);
      if (created !== created) {
        created = Date.now();
      }
      var result = {
        _id: id,
        created: created,
        updated: Date.now(),
        headers: item.headers || '',
        method: item.method,
        name: item.name,
        payload: body,
        type: 'saved',
        url: item.url,
        projectOrder: projectIndex
      };
      if (projectId) {
        result.legacyProject = projectId;
      }
      if (item.driveId) {
        result.driveId = item.driveId;
        result.type = 'google-drive';
      }
      if (item.description) {
        result.description = item.description;
      }
      return result;
    },
    // Updates `created` and `updated` fileds of the object.
    _updateItemTimings: function(item, stamp) {
      if (!item.created) {
        if (stamp) {
          item.created = stamp;
        } else {
          item.created = Date.now();
        }
      }
      item.updated = Date.now();
      return item;
    },
    // Comnputes list of ARC's headers sets from Postam data.
    _computeHeadersSets: function(sets) {
      return sets.map(set => this._computeSetObject(set));
    },
    /**
     * Computes headers set object from postman data.
     *
     * @param {Object} item Postman header set definition.
     * @return {Object} ARC's header set object
     */
    _computeSetObject: function(item) {
      item = this._updateItemTimings(item, item.timestamp);
      var value = '';
      item.headers.forEach(header => {
        if (value) {
          value += '\n';
        }
        value += header.key + ': ' + header.value;
      });
      var result = {
        _id: this.uuid(),
        created: item.created,
        updated: item.updated,
        name: item.name || 'Unnamed set',
        headers: value
      };
      return result;
    },
    /**
     * Computes list of variables to import.
     *
     * @param {Object} data Postman import object
     * @return {Array|undefined} List of variables or undefined if no variables
     * found.
     */
    _computeVariables: function(data) {
      var result = [];
      if (data.globals && data.globals.length) {
        data.globals.forEach(item => {
          let obj = this._computeVariableObject(item, 'default');
          result.push(obj);
        });
      }

      if (data.environments && data.environments.length) {
        data.environments.forEach(env => {
          if (!env.values || !env.values.length) {
            return;
          }
          let name = env.name || 'Unnamed';
          env.values.forEach(item => {
            let obj = this._computeVariableObject(item, name);
            result.push(obj);
          });
        });
      }
      return result.length ? result : undefined;
    },
    /**
     * Creates a variable object item.
     *
     * @param {Object} item Postman's variable definition.
     * @param {String} environment Environment name
     * @return {Object} ARC's variable definition.
     */
    _computeVariableObject: function(item, environment) {
      var result = {
        _id: this.uuid(),
        enabled: item.enabled || true,
        environment: environment,
        value: item.key,
        variable: item.value
      };

      return result;
    },

    _computeBody: function(item) {
      if (typeof item.data === 'string') {
        return item.data;
      }
      if (item.data instanceof Array && !item.data.length) {
        return '';
      }
      switch (item.dataMode) {
        case 'params': return this._computeFormDataBody(item);
        case 'urlencoded': return this._computeUrlEncodedBody(item);
        case 'binary': return '';
      }
    },

    _computeFormDataBody: function(item) {
      if (!item.data || !item.data.length) {
        return '';
      }
      var multipart = [];
      item.data.forEach(item => {
        let obj = {
          name: item.key,
          type: item.type,
          value: item.type === 'file' ? '' : item.value
        };
        multipart.push(obj);
      });
      item.multipart = multipart;
      item.payloadEditor = 'multipart';
      return '';
    },

    _computeUrlEncodedBody: function(item) {
      if (!item.data || !item.data.length) {
        return '';
      }
      return item.data.map(item => {
        var name = this._paramValue(item.name);
        var value = this._paramValue(item.value);
        return name + '=' + value;
      }).join('&');
    },

    /**
     * Parse input string as a payload param key or value.
     *
     * @param {String} input An input to parse.
     */
    _paramValue: function(input) {
      if (!input) {
        return String();
      }
      input = String(input);
      input = input.trim();
      return input;
    },

  });
</script>
