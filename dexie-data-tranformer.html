<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="data-transformer-behavior.html">
<!--
An element to transfer Dexie datastore objects into current data model.
-->
<script>
  Polymer({
    is: 'dexie-data-tranformer',

    behaviors: [ArcBehaviors.ImportDataTransformerBehavior],

    /**
     * Transforms legacy ARC export object based on Dexie data store
     * into current export data model.
     *
     * @param {Object} data Exported data object from the file.
     * @return {Object} New data model object.
     */
    transform: function(data) {
      return this._parseRequests(data.requests)
      .then(result => {
        var projects = this._processProjects(data.projects);
        return {
          projects: projects,
          data: this._associateProjects(result, projects)
        };
      })
      .then(data => {
        let result = {
          createdAt: new Date().toISOString(),
          version: 'unknown',
          kind: 'ARC#Import',
          requests: data.data.saved ? data.data.saved.map(item => item.request) : [],
          projects: data.projects ? data.projects.map(item => item.legacyProject) : [],
          history: data.data.history ? data.data.history.map(item => item.request) : []
        };
        // TODO: handle history data.
        return result;
      });
    },
    /**
     * In new structure projects do not have a refference to request ids. It's
     * the other way around in previous system.
     * It's a bad pattern for object stores but it must suffice for now.
     * @param {?Array} projects List of projects in the import.
     * @return {Array} preprocessed projects array
     */
    _processProjects: function(projects) {
      if (!projects || !projects.length) {
        return [];
      }
      var list = projects.map(item => this._processProjectItem(item));
      return list.filter(item => !!item);
    },
    /**
     * Creates a pre-processed project data.
     *
     * @param {Object} item Project object from the import.
     * @return {Object} Pre-processed project object with project store data
     * under the `legacyProject` property and list of requests IDs under
     * the `updateData` property.
     */
    _processProjectItem: function(item) {
      if (!item.requestIds || !item.requestIds.length) {
        return;
      }
      return {
        updateData: item.requestIds,
        legacyProject: {
          _id: this.uuid(),
          name: item.name,
          order: item.order,
          updated: item.updateTime,
          created: item.created
        }
      };
    },
    /**
     * History is placed in its own store, saved items has own store.
     * Har data are not imported this way as user cannot actually use it.
     *
     * @param {Array} requests List of requests objects from the import file.
     * @return {Promise} A promise resolved when import is ready.
     */
    _parseRequests: function(requests) {
      return new Promise(resolve => {
        this._parseRequestsDeffered(requests, resolve);
      })
      .then((result) => {
        // remove duplicates from the history.
        let ids = [];
        result.history = result.history.filter(item => {
          if (ids.indexOf(item.request._id) === -1) {
            ids[ids.length] = item.request._id;
            return true;
          }
          return false;
        });
        return result;
      });
    },
    /**
     * Parses the request data.
     * It takes only portion of the data to parse so the script release the
     * event loop and ANR screen won't appear.
     *
     * @param {Array} requests List of requests from the import.
     * @param {Function} done A callkback function to be called when ready.
     * @param {?Array} saved Final list of saved requests
     * @param {?Array} history Final list of history items.
     */
    _parseRequestsDeffered: function(requests, done, saved, history) {
      saved = saved || [];
      history = history || [];
      if (requests.length === 0) {
        done({
          saved: saved,
          history: history
        });
        return;
      }
      var len = Math.min(requests.length, 200);
      // Up to 200 loop iteration at once.
      // Then the function return and release main loop.
      for (let i = 0; i < len; i++) {
        let item = requests[i];
        if (item.type === 'history') {
          let result = this._parseHistoryItem(item);
          history.push({
            origin: result.originId,
            request: result.request
          });
        } else if (item.type === 'saved') {
          let result = this._parseSavedItem(item);
          saved.push({
            origin: result.originId,
            request: result.request
          });
        } else if (item.type === 'drive') {
          let result = this._parseDriveItem(item);
          saved.push({
            origin: result.originId,
            request: result.request
          });
        }
      }
      requests.splice(0, len);
      Polymer.RenderStatus.afterNextRender(this, function() {
        this._parseRequestsDeffered(requests, done, saved, history);
      });
    },

    _parseHistoryItem: function(item) {
      item.updateTime = item.updateTime || Date.now();
      var id = this.generateHistoryId(item.updateTime, item);
      var obj = {
        _id: id,
        method: item.method,
        url: item.url,
        updated: new Date(item.updateTime).getTime()
      };
      // payload and headers
      var har = item._har || item.har;
      var entries = har.entries;
      var entry = entries[entries.length - 1];
      if (entry) {
        let harRequest = entry.request;
        obj.headers = this._parseHarHeders(harRequest.headers);
        obj.payload = harRequest.postData.text;
        let t = new Date(entry.startedDateTime).getTime();
        if (t !== t) {
          t = Date.now();
        }
        obj.created = t;
      } else {
        obj.created = obj.updated;
      }
      obj.updated = Date.now();
      return {
        originId: item.id,
        request: obj
      };
    },

    _parseSavedItem: function(item) {
      var requestName = item.name || item._name;
      var keyName = requestName;
      if (keyName && keyName[0] === '_') {
        keyName = keyName.substr(1);
      }
      var id = this.generateRequestId({
        name: keyName,
        url: item.url,
        method: item.method
      });
      var obj = {
        _id: id,
        name: requestName,
        method: item.method,
        url: item.url,
        type: 'saved'
      };
      // payload and headers
      var harIndex = item.referenceEntry || 0;
      var har = item._har || item.har;
      if (har) {
        var entries = har.entries;
        var entry;
        if (harIndex || harIndex === 0) {
          entry = entries[harIndex];
        } else {
          entry = entries[0];
        }
        if (entry) {
          let harRequest = entry.request;
          obj.headers = this._parseHarHeders(harRequest.headers);
          obj.payload = harRequest.postData.text;
          let t = new Date(entry.startedDateTime).getTime();
          if (t !== t) {
            t = Date.now();
          }
          obj.created = t;
        }
      }
      obj.updated = Date.now();

      return {
        originId: item.id,
        request: obj
      };
    },

    _parseDriveItem: function(item) {
      var result = this._parseSavedItem(item);
      result.request.driveId = item.driveId;
      result.request.type = 'google-drive';
      return result;
    },

    _parseHarHeders: function(arr) {
      if (!arr || !arr.length) {
        return '';
      }
      return arr.map(item => {
        return item.name + ': ' + item.value;
      }).join('\n');
    },
    /**
     * Associate requests with project data.
     *
     * @param {Object} data Parsed requests object
     * @param {Array} projects List of projects
     * @return {Object} Parsed requests object
     */
    _associateProjects: function(data, projects) {
      if (!projects || !projects.length) {
        return data;
      }
      data.saved = data.saved || [];
      var savedLen = data.saved.length;
      var projectsLen = projects.length;
      for (let i = 0; i < projectsLen; i++) {
        let project = projects[i];
        let newProjectId = project.legacyProject._id;
        for (let j = 0, rLen = project.updateData.length; j < rLen; j++) {
          let rId = project.updateData[j];
          for (let k = 0; k < savedLen; k++) {
            if (data.saved[k].origin === rId) {
              if (!data.saved[k].legacyProject) {
                data.saved[k].request._id += '/' + newProjectId;
                data.saved[k].request.legacyProject = newProjectId;
                break;
              }
            }
          }
        }
      }
      return data;
    }
  });
</script>
